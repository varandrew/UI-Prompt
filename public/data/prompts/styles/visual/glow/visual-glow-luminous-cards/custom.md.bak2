# Custom Prompt

## 中文版本 (zh-CN)

你是一名精通霓虹光效的前端设计师，请生成一组「Luminous Glow Cards」界面：深色背景(#0b1021)下，卡片与按钮采用青(#3cf5ff)、洋红(#ff4f9f)、紫(#8b5cf6)的多层发光边框与渐层。需包含：标题、副标、主要 CTA 按钮，以及 3–4 张统计/功能卡片（含数字或简短描述），卡片互相对齐且具 hover/active 微动效（呼吸光晕、边框闪烁、轻微缩放）。版面需同时兼顾桌面与行动端，使用纯 HTML/CSS（不引入外部框架或 JS），色彩与阴影请集中在 CSS 变数中，并保持语义化结构。输出最终 HTML + CSS 片段。
---

You are a front-end designer specializing in neon glow effects. Create a “Luminous Glow Cards” UI on a dark background (#0b1021) using layered glowing borders and gradients in cyan (#3cf5ff), magenta (#ff4f9f), and purple (#8b5cf6). Include: a headline, a subheadline, a primary CTA button, and 3–4 stat/feature cards with numbers or short labels. Cards should align cleanly and feature hover/active micro-interactions (breathing glow, border flicker, subtle scale). Layout must adapt to both desktop and mobile. Use pure HTML/CSS only (no external frameworks or JS); keep colors/shadows in CSS variables and maintain semantic structure. Output the final HTML + CSS snippets.


---

**Comprehensive Implementation Guide**

**Visual Design Principles**:
- Establish clear visual hierarchy through size, color, contrast, and positioning
- Apply consistent spacing rhythm using modular scale (8px, 16px, 24px, 32px, 48px, 64px base units)
- Create focal points using visual weight: size contrast, color saturation, detail complexity
- Balance symmetry and asymmetry: use symmetric grids with asymmetric content placement
- Implement depth through layering: use z-index, shadows, overlaps, and transparency
- Design for scannability: users should grasp content structure within 3-5 seconds

**Color System Architecture**:
- Define semantic colors: primary (brand), secondary (support), success, warning, error, info
- Create comprehensive shade scales: 50 (lightest) through 900 (darkest) for each color
- Implement alpha variants for transparency needs (e.g., primary-500/50 for 50% opacity)
- Use CSS custom properties for dynamic theming and easy maintenance
- Apply color psychology strategically: blue for trust, green for success, red for urgency
- Test color combinations for sufficient contrast and accessibility compliance

**Component Design Patterns**:
- Buttons: Establish primary, secondary, tertiary, and ghost variants with clear hierarchy
- Cards: Design consistent card anatomy (image, title, description, actions) with flexible layouts
- Forms: Implement clear states (default, focus, filled, error, disabled, success)
- Navigation: Create persistent, clear navigation with current page indication
- Modals: Design with backdrop, proper focus management, and ESC key dismissal
- Tooltips: Position intelligently with collision detection to stay within viewport

**Interaction Design Details**:
- Provide instant visual feedback for all user actions within 100ms
- Use appropriate cursor styles: pointer for clickable, grab for draggable, text for editable
- Implement hover states that preview action outcomes when appropriate
- Apply loading states for asynchronous operations: spinners, skeletons, progress bars
- Design error states with clear messaging and recovery actions
- Add success confirmation with appropriate timing (2-4s auto-dismiss for non-critical)

**Animation Best Practices**:
- Follow duration guidelines: micro (100-200ms), macro (300-500ms), cinematic (600-1000ms+)
- Use appropriate easing: ease-out for entrances, ease-in for exits, ease-in-out for moves
- Implement meaningful motion: animations should communicate state or relationship
- Respect performance budgets: limit simultaneous animations, use GPU-accelerated properties
- Provide animation controls: pause, speed adjustment for user preference
- Test animations on low-end devices to ensure acceptable performance

**Responsive Design Strategy**:
- Start mobile-first: design for smallest screen, progressively enhance for larger
- Define clear breakpoints: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)
- Implement content-first responsive: adjust based on content needs, not just device sizes
- Use fluid layouts: combine fixed, flexible, and hybrid sizing strategies appropriately
- Test on real devices across iOS, Android, different browsers for actual user experience
- Consider orientation changes: design works in both portrait and landscape modes

**Performance Optimization Techniques**:
- Minimize render-blocking resources: inline critical CSS, defer non-critical JavaScript
- Implement lazy loading for images, videos, and below-fold content
- Use appropriate image formats: SVG for graphics, WebP/AVIF for photos
- Apply code splitting to load features on demand, reducing initial bundle size
- Optimize fonts: subset to required glyphs, use font-display: swap
- Minimize DOM depth and complexity: flatten structure where possible
- Use CSS containment to isolate expensive rendering work
- Implement resource hints: preconnect, prefetch, preload for critical resources

**Accessibility Standards Compliance**:
- Ensure WCAG 2.1 Level AA compliance minimum across all pages and components
- Implement semantic HTML: proper heading hierarchy, landmark regions, lists
- Provide keyboard navigation: all functionality available without mouse
- Add visible focus indicators: 3px+ outlines with sufficient contrast
- Include skip links for keyboard users to bypass repetitive content
- Ensure form labels and error messages are programmatically associated
- Add ARIA attributes where needed: aria-label, aria-describedby, aria-live
- Test with assistive technologies: screen readers, voice control, switch devices
- Provide text alternatives: alt text for images, captions for videos, transcripts for audio
- Respect user preferences: prefers-reduced-motion, prefers-color-scheme, prefers-contrast

**Testing & Quality Assurance**:
- Test across browsers: Chrome, Firefox, Safari, Edge for visual and functional consistency
- Validate on real devices: iOS, Android, tablets, desktops with different screen sizes
- Check with browser DevTools: accessibility audit, performance profiling, network throttling
- Use automated testing tools: Lighthouse, axe DevTools, WAVE for accessibility and performance
- Perform manual keyboard testing: ensure complete navigation without mouse
- Test with screen readers: verify content is announced correctly and in logical order
- Validate HTML and CSS: use W3C validators to catch syntax errors
- Conduct usability testing with real users to identify friction points

---

## English Version (en-US)

You are a front-end designer specializing in neon glow effects. Create a “Luminous Glow Cards” UI on a dark background (#0b1021) using layered glowing borders and gradients in cyan (#3cf5ff), magenta (#ff4f9f), and purple (#8b5cf6). Include: a headline, a subheadline, a primary CTA button, and 3–4 stat/feature cards with numbers or short labels. Cards should align cleanly and feature hover/active micro-interactions (breathing glow, border flicker, subtle scale). Layout must adapt to both desktop and mobile. Use pure HTML/CSS only (no external frameworks or JS); keep colors/shadows in CSS variables and maintain semantic structure. Output the final HTML + CSS snippets.


---

**Comprehensive Implementation Guide**

**Visual Design Principles**:
- Establish clear visual hierarchy through size, color, contrast, and positioning
- Apply consistent spacing rhythm using modular scale (8px, 16px, 24px, 32px, 48px, 64px base units)
- Create focal points using visual weight: size contrast, color saturation, detail complexity
- Balance symmetry and asymmetry: use symmetric grids with asymmetric content placement
- Implement depth through layering: use z-index, shadows, overlaps, and transparency
- Design for scannability: users should grasp content structure within 3-5 seconds

**Color System Architecture**:
- Define semantic colors: primary (brand), secondary (support), success, warning, error, info
- Create comprehensive shade scales: 50 (lightest) through 900 (darkest) for each color
- Implement alpha variants for transparency needs (e.g., primary-500/50 for 50% opacity)
- Use CSS custom properties for dynamic theming and easy maintenance
- Apply color psychology strategically: blue for trust, green for success, red for urgency
- Test color combinations for sufficient contrast and accessibility compliance

**Component Design Patterns**:
- Buttons: Establish primary, secondary, tertiary, and ghost variants with clear hierarchy
- Cards: Design consistent card anatomy (image, title, description, actions) with flexible layouts
- Forms: Implement clear states (default, focus, filled, error, disabled, success)
- Navigation: Create persistent, clear navigation with current page indication
- Modals: Design with backdrop, proper focus management, and ESC key dismissal
- Tooltips: Position intelligently with collision detection to stay within viewport

**Interaction Design Details**:
- Provide instant visual feedback for all user actions within 100ms
- Use appropriate cursor styles: pointer for clickable, grab for draggable, text for editable
- Implement hover states that preview action outcomes when appropriate
- Apply loading states for asynchronous operations: spinners, skeletons, progress bars
- Design error states with clear messaging and recovery actions
- Add success confirmation with appropriate timing (2-4s auto-dismiss for non-critical)

**Animation Best Practices**:
- Follow duration guidelines: micro (100-200ms), macro (300-500ms), cinematic (600-1000ms+)
- Use appropriate easing: ease-out for entrances, ease-in for exits, ease-in-out for moves
- Implement meaningful motion: animations should communicate state or relationship
- Respect performance budgets: limit simultaneous animations, use GPU-accelerated properties
- Provide animation controls: pause, speed adjustment for user preference
- Test animations on low-end devices to ensure acceptable performance

**Responsive Design Strategy**:
- Start mobile-first: design for smallest screen, progressively enhance for larger
- Define clear breakpoints: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)
- Implement content-first responsive: adjust based on content needs, not just device sizes
- Use fluid layouts: combine fixed, flexible, and hybrid sizing strategies appropriately
- Test on real devices across iOS, Android, different browsers for actual user experience
- Consider orientation changes: design works in both portrait and landscape modes

**Performance Optimization Techniques**:
- Minimize render-blocking resources: inline critical CSS, defer non-critical JavaScript
- Implement lazy loading for images, videos, and below-fold content
- Use appropriate image formats: SVG for graphics, WebP/AVIF for photos
- Apply code splitting to load features on demand, reducing initial bundle size
- Optimize fonts: subset to required glyphs, use font-display: swap
- Minimize DOM depth and complexity: flatten structure where possible
- Use CSS containment to isolate expensive rendering work
- Implement resource hints: preconnect, prefetch, preload for critical resources

**Accessibility Standards Compliance**:
- Ensure WCAG 2.1 Level AA compliance minimum across all pages and components
- Implement semantic HTML: proper heading hierarchy, landmark regions, lists
- Provide keyboard navigation: all functionality available without mouse
- Add visible focus indicators: 3px+ outlines with sufficient contrast
- Include skip links for keyboard users to bypass repetitive content
- Ensure form labels and error messages are programmatically associated
- Add ARIA attributes where needed: aria-label, aria-describedby, aria-live
- Test with assistive technologies: screen readers, voice control, switch devices
- Provide text alternatives: alt text for images, captions for videos, transcripts for audio
- Respect user preferences: prefers-reduced-motion, prefers-color-scheme, prefers-contrast

**Testing & Quality Assurance**:
- Test across browsers: Chrome, Firefox, Safari, Edge for visual and functional consistency
- Validate on real devices: iOS, Android, tablets, desktops with different screen sizes
- Check with browser DevTools: accessibility audit, performance profiling, network throttling
- Use automated testing tools: Lighthouse, axe DevTools, WAVE for accessibility and performance
- Perform manual keyboard testing: ensure complete navigation without mouse
- Test with screen readers: verify content is announced correctly and in logical order
- Validate HTML and CSS: use W3C validators to catch syntax errors
- Conduct usability testing with real users to identify friction points
